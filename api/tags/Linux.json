{"name":"Linux","slug":"Linux","count":3,"posts":[{"title":"/dev/stdout和/dev/stderr是什么？","slug":"stdout&stderr","date":"2020-03-07T04:15:30.000Z","updated":"2020-03-07T04:17:39.096Z","comments":true,"pin":null,"path":"api/articles/stdout&stderr.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"linux中的devstdout和devstderr\">Linux中的/dev/stdout和/dev/stderr</h2>\n<p>In the <code>/dev</code> directory, amongst the disks, TTYs, <code>urandom</code>s, and other pseudo-devices, are the files <code>/dev/stdin</code>, <code>/dev/stdout</code> and <code>/dev/stderr</code>. What are they, and what are they good for?</p>\n<p>You may have heard of standard in, standard out and standard error, the three “standard streams” which each UNIX process usually has attached to it on start. For example, <code>cat</code> run with no arguments reads from standard in and writes to standard out (achieving nothing):</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello | cat | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class=\"line\">HELLO</span><br></pre></td></tr></table></figure></div>\n<p>The standard streams don’t seem like “devices”, but there they are in <code>/dev</code>; files which any process can open, read from, and write to, just like other files. When I write to <code>/dev/stdout</code> from my shell, it’s printed to my terminal:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello &gt; /dev/stdout</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></div>\n<p>Crucially, <code>/dev/stdout</code> means different things to different processes. Above, <code>/dev/stdout</code> refers to the standard out of my shell process, which is my terminal, and that’s why <code>hello</code> printed to my screen. But if I tell <code>cp</code> to write to <code>/dev/stdout</code>, it writes to its own standard out stream, not to my shell’s standard out:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello | cp /dev/stdin /dev/stdout | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class=\"line\">HELLO</span><br></pre></td></tr></table></figure></div>\n<p>Look at that: we got <code>cp</code>, normally used for copying files, to behave just like <code>cat</code>, which copies streams! We were able to do this by telling <code>cp</code> to use its standard streams instead of files.</p>\n<p>When building shell pipelines, this can be very useful. The following pipeline grabs a JPEG from the web, converts it to a monochrome PNG, then posts the result to another web server, without creating any temporary files:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://upload.wikimedia.org/wikipedia/en/5/52/Testcard_F.jpg \\</span><br><span class=\"line\">| convert -monochrome /dev/stdin png:/dev/stdout \\</span><br><span class=\"line\">| curl -X POST --data @/dev/stdin -H &apos;Content-Type: image/png&apos; http://requestbin.fullcontact.com/13rcezq1</span><br></pre></td></tr></table></figure></div>\n<p>Processes interact with files via file descriptors. When a process opens a file, the OS gives the process a file descriptor (a number) which the process can use to read or write from the open file. We can see this with <code>strace</code>:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat foo.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">$ strace cat foo.txt</span><br><span class=\"line\">...</span><br><span class=\"line\">open(&quot;foo.txt&quot;, O_RDONLY)               = 3</span><br><span class=\"line\">...</span><br><span class=\"line\">read(3, &quot;hello\\n&quot;, 65536)               = 6</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></div>\n<p>Here, <code>cat foo.txt</code> called <code>open(&quot;foo.txt&quot;, O_RDONLY)</code>, and the OS returned the file descriptor <code>3</code>. <code>cat</code> then read from this with <code>read(3, ...)</code>.</p>\n<p>The standard streams in, out and error are at file descriptors 0, 1 and 2 respectively. The standard streams are pre-attached; the process does not have to open them. For example, <code>cat</code> run with no arguments reads from file descriptor <code>0</code> and writes to file descriptor <code>1</code>. In a shell pipeline, these standard file descriptors are references to anonymous pipes.</p>\n<p>When we run <code>cp /dev/stdin /dev/stdout</code>, the process opens the files <code>/dev/stdin</code> and <code>/dev/stdout</code> as normal, and gets back file descriptors for them. Which numbers do you think it gets back?</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/stdin&quot;, O_RDONLY)            = 3</span><br><span class=\"line\">open(&quot;/dev/stdout&quot;, O_WRONLY|O_TRUNC)   = 4</span><br></pre></td></tr></table></figure></div>\n<p>No, it doesn’t get back 0 and 1; it gets two <em>new</em> file descriptors 3 and 4. But those new file descriptors both refer to the same underlying anonymous pipe.</p>\n","text":"Linux中的/dev/stdout和/dev/stderrIn the /dev directory, amongst the disks, TTYs, urandoms, and other pseudo-devices, are the files /dev/stdin, ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}]},{"title":"Systemd使用技巧","slug":"systemd","date":"2019-10-09T12:20:31.000Z","updated":"2020-02-16T06:31:34.539Z","comments":true,"pin":null,"path":"api/articles/systemd.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"systemd\">systemd</h1>\n<p>systemd的一些简单使用技巧</p>\n<h2 id=\"基本命令\">基本命令</h2>\n<p><code>systemctl</code> 命令:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status &lt;service_name&gt;         # 检查服务的状态</span><br><span class=\"line\">systemctl start &lt;service_name&gt;          # 启动服务</span><br><span class=\"line\">systemctl stop &lt;service_name&gt;           # 停止服务</span><br><span class=\"line\">systemctl enable &lt;service_name&gt;         # enable服务, 简单讲, 让服务开机就跑起来, 具体策略按服务的配置来.</span><br><span class=\"line\">systemctl disable &lt;service_name&gt;        # disable服务, 简单讲就是服务不再自动按照规定策略来跑了, 但不会停止现在已经跑起来的服务.</span><br><span class=\"line\">systemctl --daemon-reload               # 重新加载systemd的服务列表, 安装和修改`xxx.service`需要用</span><br></pre></td></tr></table></figure></div>\n<p><code>journalctl</code>命令: (#TODO)</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">journalctl                              #可以用来看日志 (TODO)</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"service-template\">service template</h2>\n<p>下边是一个通过systemd来把一些linux下的long running的进程快速配置成服务变通的办法.</p>\n<ol>\n<li>先准备一个bash脚本, 用来long running的方式启动应用.</li>\n</ol>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># start.sh example.</span></span><br><span class=\"line\"><span class=\"comment\"># <span class=\"doctag\">NOTE:</span> use absolute path</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#!/usr/bin/sh</span></span><br><span class=\"line\">PROOT=<span class=\"string\">\"<span class=\"variable\">$( cd \"$(dirname \"$0\")</span>\"</span> ; <span class=\"built_in\">pwd</span> -P )<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"variable\">$PROOT</span>/bin/prometheus \\</span></span><br><span class=\"line\"><span class=\"string\">        --storage.tsdb.path=\"</span>/var/data/prometheus/<span class=\"string\">\" \\</span></span><br><span class=\"line\"><span class=\"string\">        --config.file=\"</span><span class=\"variable\">$PROOT</span>/conf/prometheus.yml<span class=\"string\">\"</span></span><br></pre></td></tr></table></figure></div>\n<ol start=\"2\">\n<li>然后把下边的模板改改, 保存成 <code>xxxx.service</code> 放到 <code>/etc/systemd/system/</code> 下.  这个放的位置比较较粗糙.</li>\n</ol>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=prometheus</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=/bin/sh -c &apos;/home/oliveagle/app/prometheus/start.sh 2&gt;&amp;1&apos;</span><br><span class=\"line\">User=oliveagle</span><br><span class=\"line\">Group=oliveagle</span><br><span class=\"line\">Restart=always</span><br><span class=\"line\">RestartSec=10</span><br><span class=\"line\"># restart service every xxx seconds.</span><br><span class=\"line\"># RuntimeMaxSec=604800</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\"># NOTE: use default.target</span><br><span class=\"line\">WantedBy=default.target</span><br></pre></td></tr></table></figure></div>\n<ol start=\"3\">\n<li>通过<code>systemctl</code>命令加载, 安装, 启动</li>\n</ol>\n","text":"systemdsystemd的一些简单使用技巧基本命令systemctl 命令:1<br>2<br>3<br>4<br>5<br>6<br>systemctl status &lt;service_name&gt;         # 检查服务的状态<br>systemctl s","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}]},{"title":"一些有趣的Linux网站","slug":"Linux-websites","date":"2019-10-07T12:53:32.000Z","updated":"2020-02-16T07:56:18.331Z","comments":true,"pin":null,"path":"api/articles/Linux-websites.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"一些有趣的linux网站\">一些有趣的Linux网站</h2>\n<ul>\n<li><a href=\"https://github.com/aleksandar-todorovic/awesome-linux\" target=\"_blank\" rel=\"noopener\">awesome-linux列表</a> - github 上 awesome-linux 列表，里边各种linux相关的网站</li>\n<li><a href=\"https://github.com/geekwolf/free-books/blob/master/free-programming-books.md\" target=\"_blank\" rel=\"noopener\">free-programming-books</a> - 很多开发相关的免费书籍</li>\n<li><a href=\"https://bootlin.com/docs/\" target=\"_blank\" rel=\"noopener\">bootlin.com</a> - linux 内核相关\n<ul>\n<li><a href=\"https://elixir.bootlin.com/linux/v5.4/source\" target=\"_blank\" rel=\"noopener\">elixir.bootlin.com</a> - linux kernal 源码浏览</li>\n</ul>\n</li>\n<li><a href=\"https://distrowatch.com/\" target=\"_blank\" rel=\"noopener\">distrowatch.com</a> - linux 各发行版的信息</li>\n<li><a href=\"https://www.commandlinefu.com/commands/browse\" target=\"_blank\" rel=\"noopener\">commandlinefu.com</a> - linux 命令收集网站</li>\n<li><a href=\"https://explainshell.com/#\" target=\"_blank\" rel=\"noopener\">explainshell.com</a> - 解释shell命令的网站</li>\n<li><a href=\"https://www.shortcutfoo.com/\" target=\"_blank\" rel=\"noopener\">shortcutfoo.com</a> - 练习shortcut的网站</li>\n<li><a href=\"http://vim-adventures.com/\" target=\"_blank\" rel=\"noopener\">vim-adventures.com</a> - 通过RPG游戏来联系VIM的使用</li>\n<li><a href=\"http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html\" target=\"_blank\" rel=\"noopener\">Bash Guide for Beginners</a> - Bash Guide for Beginners</li>\n<li><a href=\"https://coolshell.cn/\" target=\"_blank\" rel=\"noopener\">coolshell网站</a> - 酷壳</li>\n<li><a href=\"https://github.com/peco/peco\" target=\"_blank\" rel=\"noopener\">https://github.com/peco/peco</a> - 非常简单好用的交互式过滤工具</li>\n</ul>\n","text":"一些有趣的Linux网站awesome-linux列表 - github 上 awesome-linux 列表，里边各种linux相关的网站free-programming-books - 很多开发相关的免费书籍bootlin.com - linux 内核相关elixir.boo","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}]}]}