{"title":"/dev/stdout和/dev/stderr是什么？","slug":"stdout&stderr","date":"2020-03-07T04:15:30.000Z","updated":"2020-03-07T04:17:39.096Z","comments":true,"path":"api/articles/stdout&stderr.json","photos":[],"link":"","excerpt":"","covers":null,"keywords":"","content":"<h2 id=\"linux中的devstdout和devstderr\">Linux中的/dev/stdout和/dev/stderr</h2>\n<p>In the <code>/dev</code> directory, amongst the disks, TTYs, <code>urandom</code>s, and other pseudo-devices, are the files <code>/dev/stdin</code>, <code>/dev/stdout</code> and <code>/dev/stderr</code>. What are they, and what are they good for?</p>\n<p>You may have heard of standard in, standard out and standard error, the three “standard streams” which each UNIX process usually has attached to it on start. For example, <code>cat</code> run with no arguments reads from standard in and writes to standard out (achieving nothing):</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello | cat | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class=\"line\">HELLO</span><br></pre></td></tr></table></figure></div>\n<p>The standard streams don’t seem like “devices”, but there they are in <code>/dev</code>; files which any process can open, read from, and write to, just like other files. When I write to <code>/dev/stdout</code> from my shell, it’s printed to my terminal:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello &gt; /dev/stdout</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure></div>\n<p>Crucially, <code>/dev/stdout</code> means different things to different processes. Above, <code>/dev/stdout</code> refers to the standard out of my shell process, which is my terminal, and that’s why <code>hello</code> printed to my screen. But if I tell <code>cp</code> to write to <code>/dev/stdout</code>, it writes to its own standard out stream, not to my shell’s standard out:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo hello | cp /dev/stdin /dev/stdout | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;</span><br><span class=\"line\">HELLO</span><br></pre></td></tr></table></figure></div>\n<p>Look at that: we got <code>cp</code>, normally used for copying files, to behave just like <code>cat</code>, which copies streams! We were able to do this by telling <code>cp</code> to use its standard streams instead of files.</p>\n<p>When building shell pipelines, this can be very useful. The following pipeline grabs a JPEG from the web, converts it to a monochrome PNG, then posts the result to another web server, without creating any temporary files:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://upload.wikimedia.org/wikipedia/en/5/52/Testcard_F.jpg \\</span><br><span class=\"line\">| convert -monochrome /dev/stdin png:/dev/stdout \\</span><br><span class=\"line\">| curl -X POST --data @/dev/stdin -H &apos;Content-Type: image/png&apos; http://requestbin.fullcontact.com/13rcezq1</span><br></pre></td></tr></table></figure></div>\n<p>Processes interact with files via file descriptors. When a process opens a file, the OS gives the process a file descriptor (a number) which the process can use to read or write from the open file. We can see this with <code>strace</code>:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat foo.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">$ strace cat foo.txt</span><br><span class=\"line\">...</span><br><span class=\"line\">open(&quot;foo.txt&quot;, O_RDONLY)               = 3</span><br><span class=\"line\">...</span><br><span class=\"line\">read(3, &quot;hello\\n&quot;, 65536)               = 6</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></div>\n<p>Here, <code>cat foo.txt</code> called <code>open(&quot;foo.txt&quot;, O_RDONLY)</code>, and the OS returned the file descriptor <code>3</code>. <code>cat</code> then read from this with <code>read(3, ...)</code>.</p>\n<p>The standard streams in, out and error are at file descriptors 0, 1 and 2 respectively. The standard streams are pre-attached; the process does not have to open them. For example, <code>cat</code> run with no arguments reads from file descriptor <code>0</code> and writes to file descriptor <code>1</code>. In a shell pipeline, these standard file descriptors are references to anonymous pipes.</p>\n<p>When we run <code>cp /dev/stdin /dev/stdout</code>, the process opens the files <code>/dev/stdin</code> and <code>/dev/stdout</code> as normal, and gets back file descriptors for them. Which numbers do you think it gets back?</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAIN\"><figure class=\"iseeu highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(&quot;/dev/stdin&quot;, O_RDONLY)            = 3</span><br><span class=\"line\">open(&quot;/dev/stdout&quot;, O_WRONLY|O_TRUNC)   = 4</span><br></pre></td></tr></table></figure></div>\n<p>No, it doesn’t get back 0 and 1; it gets two <em>new</em> file descriptors 3 and 4. But those new file descriptors both refer to the same underlying anonymous pipe.</p>\n","categories":[],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}]}